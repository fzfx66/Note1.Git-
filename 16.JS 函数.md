## JS 函数

函数是对象；

四种方式定义函数：

（1）具名函数：
```
function 函数名(形参1,形参2){
    语句
    return 返回值
}
```
（2）匿名函数

上面的具名函数，去掉函数名就是匿名函数；

let a = function(x,y){return x+y}  ；也叫函数表达式；

【P】：一个考点 and  JS 变态的地方；等于号右边的具名函数的作用域只在【function fn(x,y{return x+y})】; 脱离该作用域就不存在；
```
let f1 = function fn(x,y){return x+y}

fn(1,2)
→  Uncaught ReferenceError: fn is not defined

f1(1,2)
→  3
```
（3）箭头函数
```
let f1 = x => x*x
let f2 = (x,y) => x+y    //圆括号不能省略
let f3 = (x,y) => {return x+y}  //花括号不能省
let f4 = (x,y) => ({name:'x' , age:n})  //直接返回对象会出错
```
（4）用构造函数

let f = new Function('x','y','return x+y')

基本没人用；所有函数都有 Function 构造，包括 Object、Array、Function ；

箭头函数的 => 符号的左边就是输入参数，右边就是输出参数；当有两个参数，要用括号把两个参数括起来，语法才对，否则会有歧义；

当后面的部分不只是一句，那就需要用 {} 将后面的语句括起来，并且里面要加上 return ；

若一个函数是将参数转换为对象时，需要加（）；否则 JS 会认为是一个 label 标签（如：选中部分）；

函数本身  V.S  函数调用：fn V.S fn() ；

fn 只是函数名，fn() 调用函数后函数才会执行；
```
let fn = () => console.log('hi')
let fn2 = fn
fn2()
```
↑ fn保存了匿名函数的地址，该地址被复制给了 fn2 ，fn2() 调用了匿名函数；fn 与 fn2 都是匿名函数的引用而已，真正的函数既不是 fn 也不是 fn2。

调用时机：

函数的要素（每个函数都有这些东西）：调用时机，作用域，闭包，形式参数，返回值，调用栈，函数提升，arguments（除了箭头函数），this（除了箭头函数）；

调用时机：时机不同，结果不同； （类比举例：刻舟求剑）
